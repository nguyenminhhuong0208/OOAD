{"ast":null,"code":"const JsonWebTokenError = require('./lib/JsonWebTokenError');\nconst NotBeforeError = require('./lib/NotBeforeError');\nconst TokenExpiredError = require('./lib/TokenExpiredError');\nconst decode = require('./decode');\nconst timespan = require('./lib/timespan');\nconst validateAsymmetricKey = require('./lib/validateAsymmetricKey');\nconst PS_SUPPORTED = require('./lib/psSupported');\nconst jws = require('jws');\nconst {\n  KeyObject,\n  createSecretKey,\n  createPublicKey\n} = require(\"crypto\");\nconst PUB_KEY_ALGS = ['RS256', 'RS384', 'RS512'];\nconst EC_KEY_ALGS = ['ES256', 'ES384', 'ES512'];\nconst RSA_KEY_ALGS = ['RS256', 'RS384', 'RS512'];\nconst HS_ALGS = ['HS256', 'HS384', 'HS512'];\nif (PS_SUPPORTED) {\n  PUB_KEY_ALGS.splice(PUB_KEY_ALGS.length, 0, 'PS256', 'PS384', 'PS512');\n  RSA_KEY_ALGS.splice(RSA_KEY_ALGS.length, 0, 'PS256', 'PS384', 'PS512');\n}\nmodule.exports = function (jwtString, secretOrPublicKey, options, callback) {\n  if (typeof options === 'function' && !callback) {\n    callback = options;\n    options = {};\n  }\n  if (!options) {\n    options = {};\n  }\n\n  //clone this object since we are going to mutate it.\n  options = Object.assign({}, options);\n  let done;\n  if (callback) {\n    done = callback;\n  } else {\n    done = function (err, data) {\n      if (err) throw err;\n      return data;\n    };\n  }\n  if (options.clockTimestamp && typeof options.clockTimestamp !== 'number') {\n    return done(new JsonWebTokenError('clockTimestamp must be a number'));\n  }\n  if (options.nonce !== undefined && (typeof options.nonce !== 'string' || options.nonce.trim() === '')) {\n    return done(new JsonWebTokenError('nonce must be a non-empty string'));\n  }\n  if (options.allowInvalidAsymmetricKeyTypes !== undefined && typeof options.allowInvalidAsymmetricKeyTypes !== 'boolean') {\n    return done(new JsonWebTokenError('allowInvalidAsymmetricKeyTypes must be a boolean'));\n  }\n  const clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1000);\n  if (!jwtString) {\n    return done(new JsonWebTokenError('jwt must be provided'));\n  }\n  if (typeof jwtString !== 'string') {\n    return done(new JsonWebTokenError('jwt must be a string'));\n  }\n  const parts = jwtString.split('.');\n  if (parts.length !== 3) {\n    return done(new JsonWebTokenError('jwt malformed'));\n  }\n  let decodedToken;\n  try {\n    decodedToken = decode(jwtString, {\n      complete: true\n    });\n  } catch (err) {\n    return done(err);\n  }\n  if (!decodedToken) {\n    return done(new JsonWebTokenError('invalid token'));\n  }\n  const header = decodedToken.header;\n  let getSecret;\n  if (typeof secretOrPublicKey === 'function') {\n    if (!callback) {\n      return done(new JsonWebTokenError('verify must be called asynchronous if secret or public key is provided as a callback'));\n    }\n    getSecret = secretOrPublicKey;\n  } else {\n    getSecret = function (header, secretCallback) {\n      return secretCallback(null, secretOrPublicKey);\n    };\n  }\n  return getSecret(header, function (err, secretOrPublicKey) {\n    if (err) {\n      return done(new JsonWebTokenError('error in secret or public key callback: ' + err.message));\n    }\n    const hasSignature = parts[2].trim() !== '';\n    if (!hasSignature && secretOrPublicKey) {\n      return done(new JsonWebTokenError('jwt signature is required'));\n    }\n    if (hasSignature && !secretOrPublicKey) {\n      return done(new JsonWebTokenError('secret or public key must be provided'));\n    }\n    if (!hasSignature && !options.algorithms) {\n      return done(new JsonWebTokenError('please specify \"none\" in \"algorithms\" to verify unsigned tokens'));\n    }\n    if (secretOrPublicKey != null && !(secretOrPublicKey instanceof KeyObject)) {\n      try {\n        secretOrPublicKey = createPublicKey(secretOrPublicKey);\n      } catch (_) {\n        try {\n          secretOrPublicKey = createSecretKey(typeof secretOrPublicKey === 'string' ? Buffer.from(secretOrPublicKey) : secretOrPublicKey);\n        } catch (_) {\n          return done(new JsonWebTokenError('secretOrPublicKey is not valid key material'));\n        }\n      }\n    }\n    if (!options.algorithms) {\n      if (secretOrPublicKey.type === 'secret') {\n        options.algorithms = HS_ALGS;\n      } else if (['rsa', 'rsa-pss'].includes(secretOrPublicKey.asymmetricKeyType)) {\n        options.algorithms = RSA_KEY_ALGS;\n      } else if (secretOrPublicKey.asymmetricKeyType === 'ec') {\n        options.algorithms = EC_KEY_ALGS;\n      } else {\n        options.algorithms = PUB_KEY_ALGS;\n      }\n    }\n    if (options.algorithms.indexOf(decodedToken.header.alg) === -1) {\n      return done(new JsonWebTokenError('invalid algorithm'));\n    }\n    if (header.alg.startsWith('HS') && secretOrPublicKey.type !== 'secret') {\n      return done(new JsonWebTokenError(`secretOrPublicKey must be a symmetric key when using ${header.alg}`));\n    } else if (/^(?:RS|PS|ES)/.test(header.alg) && secretOrPublicKey.type !== 'public') {\n      return done(new JsonWebTokenError(`secretOrPublicKey must be an asymmetric key when using ${header.alg}`));\n    }\n    if (!options.allowInvalidAsymmetricKeyTypes) {\n      try {\n        validateAsymmetricKey(header.alg, secretOrPublicKey);\n      } catch (e) {\n        return done(e);\n      }\n    }\n    let valid;\n    try {\n      valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey);\n    } catch (e) {\n      return done(e);\n    }\n    if (!valid) {\n      return done(new JsonWebTokenError('invalid signature'));\n    }\n    const payload = decodedToken.payload;\n    if (typeof payload.nbf !== 'undefined' && !options.ignoreNotBefore) {\n      if (typeof payload.nbf !== 'number') {\n        return done(new JsonWebTokenError('invalid nbf value'));\n      }\n      if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {\n        return done(new NotBeforeError('jwt not active', new Date(payload.nbf * 1000)));\n      }\n    }\n    if (typeof payload.exp !== 'undefined' && !options.ignoreExpiration) {\n      if (typeof payload.exp !== 'number') {\n        return done(new JsonWebTokenError('invalid exp value'));\n      }\n      if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {\n        return done(new TokenExpiredError('jwt expired', new Date(payload.exp * 1000)));\n      }\n    }\n    if (options.audience) {\n      const audiences = Array.isArray(options.audience) ? options.audience : [options.audience];\n      const target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];\n      const match = target.some(function (targetAudience) {\n        return audiences.some(function (audience) {\n          return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;\n        });\n      });\n      if (!match) {\n        return done(new JsonWebTokenError('jwt audience invalid. expected: ' + audiences.join(' or ')));\n      }\n    }\n    if (options.issuer) {\n      const invalid_issuer = typeof options.issuer === 'string' && payload.iss !== options.issuer || Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1;\n      if (invalid_issuer) {\n        return done(new JsonWebTokenError('jwt issuer invalid. expected: ' + options.issuer));\n      }\n    }\n    if (options.subject) {\n      if (payload.sub !== options.subject) {\n        return done(new JsonWebTokenError('jwt subject invalid. expected: ' + options.subject));\n      }\n    }\n    if (options.jwtid) {\n      if (payload.jti !== options.jwtid) {\n        return done(new JsonWebTokenError('jwt jwtid invalid. expected: ' + options.jwtid));\n      }\n    }\n    if (options.nonce) {\n      if (payload.nonce !== options.nonce) {\n        return done(new JsonWebTokenError('jwt nonce invalid. expected: ' + options.nonce));\n      }\n    }\n    if (options.maxAge) {\n      if (typeof payload.iat !== 'number') {\n        return done(new JsonWebTokenError('iat required when maxAge is specified'));\n      }\n      const maxAgeTimestamp = timespan(options.maxAge, payload.iat);\n      if (typeof maxAgeTimestamp === 'undefined') {\n        return done(new JsonWebTokenError('\"maxAge\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60'));\n      }\n      if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {\n        return done(new TokenExpiredError('maxAge exceeded', new Date(maxAgeTimestamp * 1000)));\n      }\n    }\n    if (options.complete === true) {\n      const signature = decodedToken.signature;\n      return done(null, {\n        header: header,\n        payload: payload,\n        signature: signature\n      });\n    }\n    return done(null, payload);\n  });\n};","map":{"version":3,"names":["JsonWebTokenError","require","NotBeforeError","TokenExpiredError","decode","timespan","validateAsymmetricKey","PS_SUPPORTED","jws","KeyObject","createSecretKey","createPublicKey","PUB_KEY_ALGS","EC_KEY_ALGS","RSA_KEY_ALGS","HS_ALGS","splice","length","module","exports","jwtString","secretOrPublicKey","options","callback","Object","assign","done","err","data","clockTimestamp","nonce","undefined","trim","allowInvalidAsymmetricKeyTypes","Math","floor","Date","now","parts","split","decodedToken","complete","header","getSecret","secretCallback","message","hasSignature","algorithms","_","Buffer","from","type","includes","asymmetricKeyType","indexOf","alg","startsWith","test","e","valid","verify","payload","nbf","ignoreNotBefore","clockTolerance","exp","ignoreExpiration","audience","audiences","Array","isArray","target","aud","match","some","targetAudience","RegExp","join","issuer","invalid_issuer","iss","subject","sub","jwtid","jti","maxAge","iat","maxAgeTimestamp","signature"],"sources":["C:/Users/Admin/Favorites/OOAD/fontend/node_modules/jsonwebtoken/verify.js"],"sourcesContent":["const JsonWebTokenError = require('./lib/JsonWebTokenError');\nconst NotBeforeError = require('./lib/NotBeforeError');\nconst TokenExpiredError = require('./lib/TokenExpiredError');\nconst decode = require('./decode');\nconst timespan = require('./lib/timespan');\nconst validateAsymmetricKey = require('./lib/validateAsymmetricKey');\nconst PS_SUPPORTED = require('./lib/psSupported');\nconst jws = require('jws');\nconst {KeyObject, createSecretKey, createPublicKey} = require(\"crypto\");\n\nconst PUB_KEY_ALGS = ['RS256', 'RS384', 'RS512'];\nconst EC_KEY_ALGS = ['ES256', 'ES384', 'ES512'];\nconst RSA_KEY_ALGS = ['RS256', 'RS384', 'RS512'];\nconst HS_ALGS = ['HS256', 'HS384', 'HS512'];\n\nif (PS_SUPPORTED) {\n  PUB_KEY_ALGS.splice(PUB_KEY_ALGS.length, 0, 'PS256', 'PS384', 'PS512');\n  RSA_KEY_ALGS.splice(RSA_KEY_ALGS.length, 0, 'PS256', 'PS384', 'PS512');\n}\n\nmodule.exports = function (jwtString, secretOrPublicKey, options, callback) {\n  if ((typeof options === 'function') && !callback) {\n    callback = options;\n    options = {};\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  //clone this object since we are going to mutate it.\n  options = Object.assign({}, options);\n\n  let done;\n\n  if (callback) {\n    done = callback;\n  } else {\n    done = function(err, data) {\n      if (err) throw err;\n      return data;\n    };\n  }\n\n  if (options.clockTimestamp && typeof options.clockTimestamp !== 'number') {\n    return done(new JsonWebTokenError('clockTimestamp must be a number'));\n  }\n\n  if (options.nonce !== undefined && (typeof options.nonce !== 'string' || options.nonce.trim() === '')) {\n    return done(new JsonWebTokenError('nonce must be a non-empty string'));\n  }\n\n  if (options.allowInvalidAsymmetricKeyTypes !== undefined && typeof options.allowInvalidAsymmetricKeyTypes !== 'boolean') {\n    return done(new JsonWebTokenError('allowInvalidAsymmetricKeyTypes must be a boolean'));\n  }\n\n  const clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1000);\n\n  if (!jwtString){\n    return done(new JsonWebTokenError('jwt must be provided'));\n  }\n\n  if (typeof jwtString !== 'string') {\n    return done(new JsonWebTokenError('jwt must be a string'));\n  }\n\n  const parts = jwtString.split('.');\n\n  if (parts.length !== 3){\n    return done(new JsonWebTokenError('jwt malformed'));\n  }\n\n  let decodedToken;\n\n  try {\n    decodedToken = decode(jwtString, { complete: true });\n  } catch(err) {\n    return done(err);\n  }\n\n  if (!decodedToken) {\n    return done(new JsonWebTokenError('invalid token'));\n  }\n\n  const header = decodedToken.header;\n  let getSecret;\n\n  if(typeof secretOrPublicKey === 'function') {\n    if(!callback) {\n      return done(new JsonWebTokenError('verify must be called asynchronous if secret or public key is provided as a callback'));\n    }\n\n    getSecret = secretOrPublicKey;\n  }\n  else {\n    getSecret = function(header, secretCallback) {\n      return secretCallback(null, secretOrPublicKey);\n    };\n  }\n\n  return getSecret(header, function(err, secretOrPublicKey) {\n    if(err) {\n      return done(new JsonWebTokenError('error in secret or public key callback: ' + err.message));\n    }\n\n    const hasSignature = parts[2].trim() !== '';\n\n    if (!hasSignature && secretOrPublicKey){\n      return done(new JsonWebTokenError('jwt signature is required'));\n    }\n\n    if (hasSignature && !secretOrPublicKey) {\n      return done(new JsonWebTokenError('secret or public key must be provided'));\n    }\n\n    if (!hasSignature && !options.algorithms) {\n      return done(new JsonWebTokenError('please specify \"none\" in \"algorithms\" to verify unsigned tokens'));\n    }\n\n    if (secretOrPublicKey != null && !(secretOrPublicKey instanceof KeyObject)) {\n      try {\n        secretOrPublicKey = createPublicKey(secretOrPublicKey);\n      } catch (_) {\n        try {\n          secretOrPublicKey = createSecretKey(typeof secretOrPublicKey === 'string' ? Buffer.from(secretOrPublicKey) : secretOrPublicKey);\n        } catch (_) {\n          return done(new JsonWebTokenError('secretOrPublicKey is not valid key material'))\n        }\n      }\n    }\n\n    if (!options.algorithms) {\n      if (secretOrPublicKey.type === 'secret') {\n        options.algorithms = HS_ALGS;\n      } else if (['rsa', 'rsa-pss'].includes(secretOrPublicKey.asymmetricKeyType)) {\n        options.algorithms = RSA_KEY_ALGS\n      } else if (secretOrPublicKey.asymmetricKeyType === 'ec') {\n        options.algorithms = EC_KEY_ALGS\n      } else {\n        options.algorithms = PUB_KEY_ALGS\n      }\n    }\n\n    if (options.algorithms.indexOf(decodedToken.header.alg) === -1) {\n      return done(new JsonWebTokenError('invalid algorithm'));\n    }\n\n    if (header.alg.startsWith('HS') && secretOrPublicKey.type !== 'secret') {\n      return done(new JsonWebTokenError((`secretOrPublicKey must be a symmetric key when using ${header.alg}`)))\n    } else if (/^(?:RS|PS|ES)/.test(header.alg) && secretOrPublicKey.type !== 'public') {\n      return done(new JsonWebTokenError((`secretOrPublicKey must be an asymmetric key when using ${header.alg}`)))\n    }\n\n    if (!options.allowInvalidAsymmetricKeyTypes) {\n      try {\n        validateAsymmetricKey(header.alg, secretOrPublicKey);\n      } catch (e) {\n        return done(e);\n      }\n    }\n\n    let valid;\n\n    try {\n      valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey);\n    } catch (e) {\n      return done(e);\n    }\n\n    if (!valid) {\n      return done(new JsonWebTokenError('invalid signature'));\n    }\n\n    const payload = decodedToken.payload;\n\n    if (typeof payload.nbf !== 'undefined' && !options.ignoreNotBefore) {\n      if (typeof payload.nbf !== 'number') {\n        return done(new JsonWebTokenError('invalid nbf value'));\n      }\n      if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {\n        return done(new NotBeforeError('jwt not active', new Date(payload.nbf * 1000)));\n      }\n    }\n\n    if (typeof payload.exp !== 'undefined' && !options.ignoreExpiration) {\n      if (typeof payload.exp !== 'number') {\n        return done(new JsonWebTokenError('invalid exp value'));\n      }\n      if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {\n        return done(new TokenExpiredError('jwt expired', new Date(payload.exp * 1000)));\n      }\n    }\n\n    if (options.audience) {\n      const audiences = Array.isArray(options.audience) ? options.audience : [options.audience];\n      const target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];\n\n      const match = target.some(function (targetAudience) {\n        return audiences.some(function (audience) {\n          return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;\n        });\n      });\n\n      if (!match) {\n        return done(new JsonWebTokenError('jwt audience invalid. expected: ' + audiences.join(' or ')));\n      }\n    }\n\n    if (options.issuer) {\n      const invalid_issuer =\n              (typeof options.issuer === 'string' && payload.iss !== options.issuer) ||\n              (Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1);\n\n      if (invalid_issuer) {\n        return done(new JsonWebTokenError('jwt issuer invalid. expected: ' + options.issuer));\n      }\n    }\n\n    if (options.subject) {\n      if (payload.sub !== options.subject) {\n        return done(new JsonWebTokenError('jwt subject invalid. expected: ' + options.subject));\n      }\n    }\n\n    if (options.jwtid) {\n      if (payload.jti !== options.jwtid) {\n        return done(new JsonWebTokenError('jwt jwtid invalid. expected: ' + options.jwtid));\n      }\n    }\n\n    if (options.nonce) {\n      if (payload.nonce !== options.nonce) {\n        return done(new JsonWebTokenError('jwt nonce invalid. expected: ' + options.nonce));\n      }\n    }\n\n    if (options.maxAge) {\n      if (typeof payload.iat !== 'number') {\n        return done(new JsonWebTokenError('iat required when maxAge is specified'));\n      }\n\n      const maxAgeTimestamp = timespan(options.maxAge, payload.iat);\n      if (typeof maxAgeTimestamp === 'undefined') {\n        return done(new JsonWebTokenError('\"maxAge\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60'));\n      }\n      if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {\n        return done(new TokenExpiredError('maxAge exceeded', new Date(maxAgeTimestamp * 1000)));\n      }\n    }\n\n    if (options.complete === true) {\n      const signature = decodedToken.signature;\n\n      return done(null, {\n        header: header,\n        payload: payload,\n        signature: signature\n      });\n    }\n\n    return done(null, payload);\n  });\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}