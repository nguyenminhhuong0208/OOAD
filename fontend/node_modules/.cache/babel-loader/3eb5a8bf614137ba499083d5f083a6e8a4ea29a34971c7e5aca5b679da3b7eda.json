{"ast":null,"code":"const timespan = require('./lib/timespan');\nconst PS_SUPPORTED = require('./lib/psSupported');\nconst validateAsymmetricKey = require('./lib/validateAsymmetricKey');\nconst jws = require('jws');\nconst includes = require('lodash.includes');\nconst isBoolean = require('lodash.isboolean');\nconst isInteger = require('lodash.isinteger');\nconst isNumber = require('lodash.isnumber');\nconst isPlainObject = require('lodash.isplainobject');\nconst isString = require('lodash.isstring');\nconst once = require('lodash.once');\nconst {\n  KeyObject,\n  createSecretKey,\n  createPrivateKey\n} = require('crypto');\nconst SUPPORTED_ALGS = ['RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'ES512', 'HS256', 'HS384', 'HS512', 'none'];\nif (PS_SUPPORTED) {\n  SUPPORTED_ALGS.splice(3, 0, 'PS256', 'PS384', 'PS512');\n}\nconst sign_options_schema = {\n  expiresIn: {\n    isValid: function (value) {\n      return isInteger(value) || isString(value) && value;\n    },\n    message: '\"expiresIn\" should be a number of seconds or string representing a timespan'\n  },\n  notBefore: {\n    isValid: function (value) {\n      return isInteger(value) || isString(value) && value;\n    },\n    message: '\"notBefore\" should be a number of seconds or string representing a timespan'\n  },\n  audience: {\n    isValid: function (value) {\n      return isString(value) || Array.isArray(value);\n    },\n    message: '\"audience\" must be a string or array'\n  },\n  algorithm: {\n    isValid: includes.bind(null, SUPPORTED_ALGS),\n    message: '\"algorithm\" must be a valid string enum value'\n  },\n  header: {\n    isValid: isPlainObject,\n    message: '\"header\" must be an object'\n  },\n  encoding: {\n    isValid: isString,\n    message: '\"encoding\" must be a string'\n  },\n  issuer: {\n    isValid: isString,\n    message: '\"issuer\" must be a string'\n  },\n  subject: {\n    isValid: isString,\n    message: '\"subject\" must be a string'\n  },\n  jwtid: {\n    isValid: isString,\n    message: '\"jwtid\" must be a string'\n  },\n  noTimestamp: {\n    isValid: isBoolean,\n    message: '\"noTimestamp\" must be a boolean'\n  },\n  keyid: {\n    isValid: isString,\n    message: '\"keyid\" must be a string'\n  },\n  mutatePayload: {\n    isValid: isBoolean,\n    message: '\"mutatePayload\" must be a boolean'\n  },\n  allowInsecureKeySizes: {\n    isValid: isBoolean,\n    message: '\"allowInsecureKeySizes\" must be a boolean'\n  },\n  allowInvalidAsymmetricKeyTypes: {\n    isValid: isBoolean,\n    message: '\"allowInvalidAsymmetricKeyTypes\" must be a boolean'\n  }\n};\nconst registered_claims_schema = {\n  iat: {\n    isValid: isNumber,\n    message: '\"iat\" should be a number of seconds'\n  },\n  exp: {\n    isValid: isNumber,\n    message: '\"exp\" should be a number of seconds'\n  },\n  nbf: {\n    isValid: isNumber,\n    message: '\"nbf\" should be a number of seconds'\n  }\n};\nfunction validate(schema, allowUnknown, object, parameterName) {\n  if (!isPlainObject(object)) {\n    throw new Error('Expected \"' + parameterName + '\" to be a plain object.');\n  }\n  Object.keys(object).forEach(function (key) {\n    const validator = schema[key];\n    if (!validator) {\n      if (!allowUnknown) {\n        throw new Error('\"' + key + '\" is not allowed in \"' + parameterName + '\"');\n      }\n      return;\n    }\n    if (!validator.isValid(object[key])) {\n      throw new Error(validator.message);\n    }\n  });\n}\nfunction validateOptions(options) {\n  return validate(sign_options_schema, false, options, 'options');\n}\nfunction validatePayload(payload) {\n  return validate(registered_claims_schema, true, payload, 'payload');\n}\nconst options_to_payload = {\n  'audience': 'aud',\n  'issuer': 'iss',\n  'subject': 'sub',\n  'jwtid': 'jti'\n};\nconst options_for_objects = ['expiresIn', 'notBefore', 'noTimestamp', 'audience', 'issuer', 'subject', 'jwtid'];\nmodule.exports = function (payload, secretOrPrivateKey, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  } else {\n    options = options || {};\n  }\n  const isObjectPayload = typeof payload === 'object' && !Buffer.isBuffer(payload);\n  const header = Object.assign({\n    alg: options.algorithm || 'HS256',\n    typ: isObjectPayload ? 'JWT' : undefined,\n    kid: options.keyid\n  }, options.header);\n  function failure(err) {\n    if (callback) {\n      return callback(err);\n    }\n    throw err;\n  }\n  if (!secretOrPrivateKey && options.algorithm !== 'none') {\n    return failure(new Error('secretOrPrivateKey must have a value'));\n  }\n  if (secretOrPrivateKey != null && !(secretOrPrivateKey instanceof KeyObject)) {\n    try {\n      secretOrPrivateKey = createPrivateKey(secretOrPrivateKey);\n    } catch (_) {\n      try {\n        secretOrPrivateKey = createSecretKey(typeof secretOrPrivateKey === 'string' ? Buffer.from(secretOrPrivateKey) : secretOrPrivateKey);\n      } catch (_) {\n        return failure(new Error('secretOrPrivateKey is not valid key material'));\n      }\n    }\n  }\n  if (header.alg.startsWith('HS') && secretOrPrivateKey.type !== 'secret') {\n    return failure(new Error(`secretOrPrivateKey must be a symmetric key when using ${header.alg}`));\n  } else if (/^(?:RS|PS|ES)/.test(header.alg)) {\n    if (secretOrPrivateKey.type !== 'private') {\n      return failure(new Error(`secretOrPrivateKey must be an asymmetric key when using ${header.alg}`));\n    }\n    if (!options.allowInsecureKeySizes && !header.alg.startsWith('ES') && secretOrPrivateKey.asymmetricKeyDetails !== undefined &&\n    //KeyObject.asymmetricKeyDetails is supported in Node 15+\n    secretOrPrivateKey.asymmetricKeyDetails.modulusLength < 2048) {\n      return failure(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));\n    }\n  }\n  if (typeof payload === 'undefined') {\n    return failure(new Error('payload is required'));\n  } else if (isObjectPayload) {\n    try {\n      validatePayload(payload);\n    } catch (error) {\n      return failure(error);\n    }\n    if (!options.mutatePayload) {\n      payload = Object.assign({}, payload);\n    }\n  } else {\n    const invalid_options = options_for_objects.filter(function (opt) {\n      return typeof options[opt] !== 'undefined';\n    });\n    if (invalid_options.length > 0) {\n      return failure(new Error('invalid ' + invalid_options.join(',') + ' option for ' + typeof payload + ' payload'));\n    }\n  }\n  if (typeof payload.exp !== 'undefined' && typeof options.expiresIn !== 'undefined') {\n    return failure(new Error('Bad \"options.expiresIn\" option the payload already has an \"exp\" property.'));\n  }\n  if (typeof payload.nbf !== 'undefined' && typeof options.notBefore !== 'undefined') {\n    return failure(new Error('Bad \"options.notBefore\" option the payload already has an \"nbf\" property.'));\n  }\n  try {\n    validateOptions(options);\n  } catch (error) {\n    return failure(error);\n  }\n  if (!options.allowInvalidAsymmetricKeyTypes) {\n    try {\n      validateAsymmetricKey(header.alg, secretOrPrivateKey);\n    } catch (error) {\n      return failure(error);\n    }\n  }\n  const timestamp = payload.iat || Math.floor(Date.now() / 1000);\n  if (options.noTimestamp) {\n    delete payload.iat;\n  } else if (isObjectPayload) {\n    payload.iat = timestamp;\n  }\n  if (typeof options.notBefore !== 'undefined') {\n    try {\n      payload.nbf = timespan(options.notBefore, timestamp);\n    } catch (err) {\n      return failure(err);\n    }\n    if (typeof payload.nbf === 'undefined') {\n      return failure(new Error('\"notBefore\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60'));\n    }\n  }\n  if (typeof options.expiresIn !== 'undefined' && typeof payload === 'object') {\n    try {\n      payload.exp = timespan(options.expiresIn, timestamp);\n    } catch (err) {\n      return failure(err);\n    }\n    if (typeof payload.exp === 'undefined') {\n      return failure(new Error('\"expiresIn\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60'));\n    }\n  }\n  Object.keys(options_to_payload).forEach(function (key) {\n    const claim = options_to_payload[key];\n    if (typeof options[key] !== 'undefined') {\n      if (typeof payload[claim] !== 'undefined') {\n        return failure(new Error('Bad \"options.' + key + '\" option. The payload already has an \"' + claim + '\" property.'));\n      }\n      payload[claim] = options[key];\n    }\n  });\n  const encoding = options.encoding || 'utf8';\n  if (typeof callback === 'function') {\n    callback = callback && once(callback);\n    jws.createSign({\n      header: header,\n      privateKey: secretOrPrivateKey,\n      payload: payload,\n      encoding: encoding\n    }).once('error', callback).once('done', function (signature) {\n      // TODO: Remove in favor of the modulus length check before signing once node 15+ is the minimum supported version\n      if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {\n        return callback(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));\n      }\n      callback(null, signature);\n    });\n  } else {\n    let signature = jws.sign({\n      header: header,\n      payload: payload,\n      secret: secretOrPrivateKey,\n      encoding: encoding\n    });\n    // TODO: Remove in favor of the modulus length check before signing once node 15+ is the minimum supported version\n    if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {\n      throw new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`);\n    }\n    return signature;\n  }\n};","map":{"version":3,"names":["timespan","require","PS_SUPPORTED","validateAsymmetricKey","jws","includes","isBoolean","isInteger","isNumber","isPlainObject","isString","once","KeyObject","createSecretKey","createPrivateKey","SUPPORTED_ALGS","splice","sign_options_schema","expiresIn","isValid","value","message","notBefore","audience","Array","isArray","algorithm","bind","header","encoding","issuer","subject","jwtid","noTimestamp","keyid","mutatePayload","allowInsecureKeySizes","allowInvalidAsymmetricKeyTypes","registered_claims_schema","iat","exp","nbf","validate","schema","allowUnknown","object","parameterName","Error","Object","keys","forEach","key","validator","validateOptions","options","validatePayload","payload","options_to_payload","options_for_objects","module","exports","secretOrPrivateKey","callback","isObjectPayload","Buffer","isBuffer","assign","alg","typ","undefined","kid","failure","err","_","from","startsWith","type","test","asymmetricKeyDetails","modulusLength","error","invalid_options","filter","opt","length","join","timestamp","Math","floor","Date","now","claim","createSign","privateKey","signature","sign","secret"],"sources":["C:/Users/Admin/Favorites/OOAD/fontend/node_modules/jsonwebtoken/sign.js"],"sourcesContent":["const timespan = require('./lib/timespan');\nconst PS_SUPPORTED = require('./lib/psSupported');\nconst validateAsymmetricKey = require('./lib/validateAsymmetricKey');\nconst jws = require('jws');\nconst includes = require('lodash.includes');\nconst isBoolean = require('lodash.isboolean');\nconst isInteger = require('lodash.isinteger');\nconst isNumber = require('lodash.isnumber');\nconst isPlainObject = require('lodash.isplainobject');\nconst isString = require('lodash.isstring');\nconst once = require('lodash.once');\nconst { KeyObject, createSecretKey, createPrivateKey } = require('crypto')\n\nconst SUPPORTED_ALGS = ['RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'ES512', 'HS256', 'HS384', 'HS512', 'none'];\nif (PS_SUPPORTED) {\n  SUPPORTED_ALGS.splice(3, 0, 'PS256', 'PS384', 'PS512');\n}\n\nconst sign_options_schema = {\n  expiresIn: { isValid: function(value) { return isInteger(value) || (isString(value) && value); }, message: '\"expiresIn\" should be a number of seconds or string representing a timespan' },\n  notBefore: { isValid: function(value) { return isInteger(value) || (isString(value) && value); }, message: '\"notBefore\" should be a number of seconds or string representing a timespan' },\n  audience: { isValid: function(value) { return isString(value) || Array.isArray(value); }, message: '\"audience\" must be a string or array' },\n  algorithm: { isValid: includes.bind(null, SUPPORTED_ALGS), message: '\"algorithm\" must be a valid string enum value' },\n  header: { isValid: isPlainObject, message: '\"header\" must be an object' },\n  encoding: { isValid: isString, message: '\"encoding\" must be a string' },\n  issuer: { isValid: isString, message: '\"issuer\" must be a string' },\n  subject: { isValid: isString, message: '\"subject\" must be a string' },\n  jwtid: { isValid: isString, message: '\"jwtid\" must be a string' },\n  noTimestamp: { isValid: isBoolean, message: '\"noTimestamp\" must be a boolean' },\n  keyid: { isValid: isString, message: '\"keyid\" must be a string' },\n  mutatePayload: { isValid: isBoolean, message: '\"mutatePayload\" must be a boolean' },\n  allowInsecureKeySizes: { isValid: isBoolean, message: '\"allowInsecureKeySizes\" must be a boolean'},\n  allowInvalidAsymmetricKeyTypes: { isValid: isBoolean, message: '\"allowInvalidAsymmetricKeyTypes\" must be a boolean'}\n};\n\nconst registered_claims_schema = {\n  iat: { isValid: isNumber, message: '\"iat\" should be a number of seconds' },\n  exp: { isValid: isNumber, message: '\"exp\" should be a number of seconds' },\n  nbf: { isValid: isNumber, message: '\"nbf\" should be a number of seconds' }\n};\n\nfunction validate(schema, allowUnknown, object, parameterName) {\n  if (!isPlainObject(object)) {\n    throw new Error('Expected \"' + parameterName + '\" to be a plain object.');\n  }\n  Object.keys(object)\n    .forEach(function(key) {\n      const validator = schema[key];\n      if (!validator) {\n        if (!allowUnknown) {\n          throw new Error('\"' + key + '\" is not allowed in \"' + parameterName + '\"');\n        }\n        return;\n      }\n      if (!validator.isValid(object[key])) {\n        throw new Error(validator.message);\n      }\n    });\n}\n\nfunction validateOptions(options) {\n  return validate(sign_options_schema, false, options, 'options');\n}\n\nfunction validatePayload(payload) {\n  return validate(registered_claims_schema, true, payload, 'payload');\n}\n\nconst options_to_payload = {\n  'audience': 'aud',\n  'issuer': 'iss',\n  'subject': 'sub',\n  'jwtid': 'jti'\n};\n\nconst options_for_objects = [\n  'expiresIn',\n  'notBefore',\n  'noTimestamp',\n  'audience',\n  'issuer',\n  'subject',\n  'jwtid',\n];\n\nmodule.exports = function (payload, secretOrPrivateKey, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  } else {\n    options = options || {};\n  }\n\n  const isObjectPayload = typeof payload === 'object' &&\n                        !Buffer.isBuffer(payload);\n\n  const header = Object.assign({\n    alg: options.algorithm || 'HS256',\n    typ: isObjectPayload ? 'JWT' : undefined,\n    kid: options.keyid\n  }, options.header);\n\n  function failure(err) {\n    if (callback) {\n      return callback(err);\n    }\n    throw err;\n  }\n\n  if (!secretOrPrivateKey && options.algorithm !== 'none') {\n    return failure(new Error('secretOrPrivateKey must have a value'));\n  }\n\n  if (secretOrPrivateKey != null && !(secretOrPrivateKey instanceof KeyObject)) {\n    try {\n      secretOrPrivateKey = createPrivateKey(secretOrPrivateKey)\n    } catch (_) {\n      try {\n        secretOrPrivateKey = createSecretKey(typeof secretOrPrivateKey === 'string' ? Buffer.from(secretOrPrivateKey) : secretOrPrivateKey)\n      } catch (_) {\n        return failure(new Error('secretOrPrivateKey is not valid key material'));\n      }\n    }\n  }\n\n  if (header.alg.startsWith('HS') && secretOrPrivateKey.type !== 'secret') {\n    return failure(new Error((`secretOrPrivateKey must be a symmetric key when using ${header.alg}`)))\n  } else if (/^(?:RS|PS|ES)/.test(header.alg)) {\n    if (secretOrPrivateKey.type !== 'private') {\n      return failure(new Error((`secretOrPrivateKey must be an asymmetric key when using ${header.alg}`)))\n    }\n    if (!options.allowInsecureKeySizes &&\n      !header.alg.startsWith('ES') &&\n      secretOrPrivateKey.asymmetricKeyDetails !== undefined && //KeyObject.asymmetricKeyDetails is supported in Node 15+\n      secretOrPrivateKey.asymmetricKeyDetails.modulusLength < 2048) {\n      return failure(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));\n    }\n  }\n\n  if (typeof payload === 'undefined') {\n    return failure(new Error('payload is required'));\n  } else if (isObjectPayload) {\n    try {\n      validatePayload(payload);\n    }\n    catch (error) {\n      return failure(error);\n    }\n    if (!options.mutatePayload) {\n      payload = Object.assign({},payload);\n    }\n  } else {\n    const invalid_options = options_for_objects.filter(function (opt) {\n      return typeof options[opt] !== 'undefined';\n    });\n\n    if (invalid_options.length > 0) {\n      return failure(new Error('invalid ' + invalid_options.join(',') + ' option for ' + (typeof payload ) + ' payload'));\n    }\n  }\n\n  if (typeof payload.exp !== 'undefined' && typeof options.expiresIn !== 'undefined') {\n    return failure(new Error('Bad \"options.expiresIn\" option the payload already has an \"exp\" property.'));\n  }\n\n  if (typeof payload.nbf !== 'undefined' && typeof options.notBefore !== 'undefined') {\n    return failure(new Error('Bad \"options.notBefore\" option the payload already has an \"nbf\" property.'));\n  }\n\n  try {\n    validateOptions(options);\n  }\n  catch (error) {\n    return failure(error);\n  }\n\n  if (!options.allowInvalidAsymmetricKeyTypes) {\n    try {\n      validateAsymmetricKey(header.alg, secretOrPrivateKey);\n    } catch (error) {\n      return failure(error);\n    }\n  }\n\n  const timestamp = payload.iat || Math.floor(Date.now() / 1000);\n\n  if (options.noTimestamp) {\n    delete payload.iat;\n  } else if (isObjectPayload) {\n    payload.iat = timestamp;\n  }\n\n  if (typeof options.notBefore !== 'undefined') {\n    try {\n      payload.nbf = timespan(options.notBefore, timestamp);\n    }\n    catch (err) {\n      return failure(err);\n    }\n    if (typeof payload.nbf === 'undefined') {\n      return failure(new Error('\"notBefore\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60'));\n    }\n  }\n\n  if (typeof options.expiresIn !== 'undefined' && typeof payload === 'object') {\n    try {\n      payload.exp = timespan(options.expiresIn, timestamp);\n    }\n    catch (err) {\n      return failure(err);\n    }\n    if (typeof payload.exp === 'undefined') {\n      return failure(new Error('\"expiresIn\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60'));\n    }\n  }\n\n  Object.keys(options_to_payload).forEach(function (key) {\n    const claim = options_to_payload[key];\n    if (typeof options[key] !== 'undefined') {\n      if (typeof payload[claim] !== 'undefined') {\n        return failure(new Error('Bad \"options.' + key + '\" option. The payload already has an \"' + claim + '\" property.'));\n      }\n      payload[claim] = options[key];\n    }\n  });\n\n  const encoding = options.encoding || 'utf8';\n\n  if (typeof callback === 'function') {\n    callback = callback && once(callback);\n\n    jws.createSign({\n      header: header,\n      privateKey: secretOrPrivateKey,\n      payload: payload,\n      encoding: encoding\n    }).once('error', callback)\n      .once('done', function (signature) {\n        // TODO: Remove in favor of the modulus length check before signing once node 15+ is the minimum supported version\n        if(!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {\n          return callback(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`))\n        }\n        callback(null, signature);\n      });\n  } else {\n    let signature = jws.sign({header: header, payload: payload, secret: secretOrPrivateKey, encoding: encoding});\n    // TODO: Remove in favor of the modulus length check before signing once node 15+ is the minimum supported version\n    if(!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {\n      throw new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`)\n    }\n    return signature\n  }\n};\n"],"mappings":"AAAA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,gBAAgB,CAAC;AAC1C,MAAMC,YAAY,GAAGD,OAAO,CAAC,mBAAmB,CAAC;AACjD,MAAME,qBAAqB,GAAGF,OAAO,CAAC,6BAA6B,CAAC;AACpE,MAAMG,GAAG,GAAGH,OAAO,CAAC,KAAK,CAAC;AAC1B,MAAMI,QAAQ,GAAGJ,OAAO,CAAC,iBAAiB,CAAC;AAC3C,MAAMK,SAAS,GAAGL,OAAO,CAAC,kBAAkB,CAAC;AAC7C,MAAMM,SAAS,GAAGN,OAAO,CAAC,kBAAkB,CAAC;AAC7C,MAAMO,QAAQ,GAAGP,OAAO,CAAC,iBAAiB,CAAC;AAC3C,MAAMQ,aAAa,GAAGR,OAAO,CAAC,sBAAsB,CAAC;AACrD,MAAMS,QAAQ,GAAGT,OAAO,CAAC,iBAAiB,CAAC;AAC3C,MAAMU,IAAI,GAAGV,OAAO,CAAC,aAAa,CAAC;AACnC,MAAM;EAAEW,SAAS;EAAEC,eAAe;EAAEC;AAAiB,CAAC,GAAGb,OAAO,CAAC,QAAQ,CAAC;AAE1E,MAAMc,cAAc,GAAG,CAAC,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,MAAM,CAAC;AAChH,IAAIb,YAAY,EAAE;EAChBa,cAAc,CAACC,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,CAAC;AACxD;AAEA,MAAMC,mBAAmB,GAAG;EAC1BC,SAAS,EAAE;IAAEC,OAAO,EAAE,SAAAA,CAASC,KAAK,EAAE;MAAE,OAAOb,SAAS,CAACa,KAAK,CAAC,IAAKV,QAAQ,CAACU,KAAK,CAAC,IAAIA,KAAM;IAAE,CAAC;IAAEC,OAAO,EAAE;EAA8E,CAAC;EAC1LC,SAAS,EAAE;IAAEH,OAAO,EAAE,SAAAA,CAASC,KAAK,EAAE;MAAE,OAAOb,SAAS,CAACa,KAAK,CAAC,IAAKV,QAAQ,CAACU,KAAK,CAAC,IAAIA,KAAM;IAAE,CAAC;IAAEC,OAAO,EAAE;EAA8E,CAAC;EAC1LE,QAAQ,EAAE;IAAEJ,OAAO,EAAE,SAAAA,CAASC,KAAK,EAAE;MAAE,OAAOV,QAAQ,CAACU,KAAK,CAAC,IAAII,KAAK,CAACC,OAAO,CAACL,KAAK,CAAC;IAAE,CAAC;IAAEC,OAAO,EAAE;EAAuC,CAAC;EAC3IK,SAAS,EAAE;IAAEP,OAAO,EAAEd,QAAQ,CAACsB,IAAI,CAAC,IAAI,EAAEZ,cAAc,CAAC;IAAEM,OAAO,EAAE;EAAgD,CAAC;EACrHO,MAAM,EAAE;IAAET,OAAO,EAAEV,aAAa;IAAEY,OAAO,EAAE;EAA6B,CAAC;EACzEQ,QAAQ,EAAE;IAAEV,OAAO,EAAET,QAAQ;IAAEW,OAAO,EAAE;EAA8B,CAAC;EACvES,MAAM,EAAE;IAAEX,OAAO,EAAET,QAAQ;IAAEW,OAAO,EAAE;EAA4B,CAAC;EACnEU,OAAO,EAAE;IAAEZ,OAAO,EAAET,QAAQ;IAAEW,OAAO,EAAE;EAA6B,CAAC;EACrEW,KAAK,EAAE;IAAEb,OAAO,EAAET,QAAQ;IAAEW,OAAO,EAAE;EAA2B,CAAC;EACjEY,WAAW,EAAE;IAAEd,OAAO,EAAEb,SAAS;IAAEe,OAAO,EAAE;EAAkC,CAAC;EAC/Ea,KAAK,EAAE;IAAEf,OAAO,EAAET,QAAQ;IAAEW,OAAO,EAAE;EAA2B,CAAC;EACjEc,aAAa,EAAE;IAAEhB,OAAO,EAAEb,SAAS;IAAEe,OAAO,EAAE;EAAoC,CAAC;EACnFe,qBAAqB,EAAE;IAAEjB,OAAO,EAAEb,SAAS;IAAEe,OAAO,EAAE;EAA2C,CAAC;EAClGgB,8BAA8B,EAAE;IAAElB,OAAO,EAAEb,SAAS;IAAEe,OAAO,EAAE;EAAoD;AACrH,CAAC;AAED,MAAMiB,wBAAwB,GAAG;EAC/BC,GAAG,EAAE;IAAEpB,OAAO,EAAEX,QAAQ;IAAEa,OAAO,EAAE;EAAsC,CAAC;EAC1EmB,GAAG,EAAE;IAAErB,OAAO,EAAEX,QAAQ;IAAEa,OAAO,EAAE;EAAsC,CAAC;EAC1EoB,GAAG,EAAE;IAAEtB,OAAO,EAAEX,QAAQ;IAAEa,OAAO,EAAE;EAAsC;AAC3E,CAAC;AAED,SAASqB,QAAQA,CAACC,MAAM,EAAEC,YAAY,EAAEC,MAAM,EAAEC,aAAa,EAAE;EAC7D,IAAI,CAACrC,aAAa,CAACoC,MAAM,CAAC,EAAE;IAC1B,MAAM,IAAIE,KAAK,CAAC,YAAY,GAAGD,aAAa,GAAG,yBAAyB,CAAC;EAC3E;EACAE,MAAM,CAACC,IAAI,CAACJ,MAAM,CAAC,CAChBK,OAAO,CAAC,UAASC,GAAG,EAAE;IACrB,MAAMC,SAAS,GAAGT,MAAM,CAACQ,GAAG,CAAC;IAC7B,IAAI,CAACC,SAAS,EAAE;MACd,IAAI,CAACR,YAAY,EAAE;QACjB,MAAM,IAAIG,KAAK,CAAC,GAAG,GAAGI,GAAG,GAAG,uBAAuB,GAAGL,aAAa,GAAG,GAAG,CAAC;MAC5E;MACA;IACF;IACA,IAAI,CAACM,SAAS,CAACjC,OAAO,CAAC0B,MAAM,CAACM,GAAG,CAAC,CAAC,EAAE;MACnC,MAAM,IAAIJ,KAAK,CAACK,SAAS,CAAC/B,OAAO,CAAC;IACpC;EACF,CAAC,CAAC;AACN;AAEA,SAASgC,eAAeA,CAACC,OAAO,EAAE;EAChC,OAAOZ,QAAQ,CAACzB,mBAAmB,EAAE,KAAK,EAAEqC,OAAO,EAAE,SAAS,CAAC;AACjE;AAEA,SAASC,eAAeA,CAACC,OAAO,EAAE;EAChC,OAAOd,QAAQ,CAACJ,wBAAwB,EAAE,IAAI,EAAEkB,OAAO,EAAE,SAAS,CAAC;AACrE;AAEA,MAAMC,kBAAkB,GAAG;EACzB,UAAU,EAAE,KAAK;EACjB,QAAQ,EAAE,KAAK;EACf,SAAS,EAAE,KAAK;EAChB,OAAO,EAAE;AACX,CAAC;AAED,MAAMC,mBAAmB,GAAG,CAC1B,WAAW,EACX,WAAW,EACX,aAAa,EACb,UAAU,EACV,QAAQ,EACR,SAAS,EACT,OAAO,CACR;AAEDC,MAAM,CAACC,OAAO,GAAG,UAAUJ,OAAO,EAAEK,kBAAkB,EAAEP,OAAO,EAAEQ,QAAQ,EAAE;EACzE,IAAI,OAAOR,OAAO,KAAK,UAAU,EAAE;IACjCQ,QAAQ,GAAGR,OAAO;IAClBA,OAAO,GAAG,CAAC,CAAC;EACd,CAAC,MAAM;IACLA,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EACzB;EAEA,MAAMS,eAAe,GAAG,OAAOP,OAAO,KAAK,QAAQ,IAC7B,CAACQ,MAAM,CAACC,QAAQ,CAACT,OAAO,CAAC;EAE/C,MAAM5B,MAAM,GAAGoB,MAAM,CAACkB,MAAM,CAAC;IAC3BC,GAAG,EAAEb,OAAO,CAAC5B,SAAS,IAAI,OAAO;IACjC0C,GAAG,EAAEL,eAAe,GAAG,KAAK,GAAGM,SAAS;IACxCC,GAAG,EAAEhB,OAAO,CAACpB;EACf,CAAC,EAAEoB,OAAO,CAAC1B,MAAM,CAAC;EAElB,SAAS2C,OAAOA,CAACC,GAAG,EAAE;IACpB,IAAIV,QAAQ,EAAE;MACZ,OAAOA,QAAQ,CAACU,GAAG,CAAC;IACtB;IACA,MAAMA,GAAG;EACX;EAEA,IAAI,CAACX,kBAAkB,IAAIP,OAAO,CAAC5B,SAAS,KAAK,MAAM,EAAE;IACvD,OAAO6C,OAAO,CAAC,IAAIxB,KAAK,CAAC,sCAAsC,CAAC,CAAC;EACnE;EAEA,IAAIc,kBAAkB,IAAI,IAAI,IAAI,EAAEA,kBAAkB,YAAYjD,SAAS,CAAC,EAAE;IAC5E,IAAI;MACFiD,kBAAkB,GAAG/C,gBAAgB,CAAC+C,kBAAkB,CAAC;IAC3D,CAAC,CAAC,OAAOY,CAAC,EAAE;MACV,IAAI;QACFZ,kBAAkB,GAAGhD,eAAe,CAAC,OAAOgD,kBAAkB,KAAK,QAAQ,GAAGG,MAAM,CAACU,IAAI,CAACb,kBAAkB,CAAC,GAAGA,kBAAkB,CAAC;MACrI,CAAC,CAAC,OAAOY,CAAC,EAAE;QACV,OAAOF,OAAO,CAAC,IAAIxB,KAAK,CAAC,8CAA8C,CAAC,CAAC;MAC3E;IACF;EACF;EAEA,IAAInB,MAAM,CAACuC,GAAG,CAACQ,UAAU,CAAC,IAAI,CAAC,IAAId,kBAAkB,CAACe,IAAI,KAAK,QAAQ,EAAE;IACvE,OAAOL,OAAO,CAAC,IAAIxB,KAAK,CAAG,yDAAwDnB,MAAM,CAACuC,GAAI,EAAE,CAAC,CAAC;EACpG,CAAC,MAAM,IAAI,eAAe,CAACU,IAAI,CAACjD,MAAM,CAACuC,GAAG,CAAC,EAAE;IAC3C,IAAIN,kBAAkB,CAACe,IAAI,KAAK,SAAS,EAAE;MACzC,OAAOL,OAAO,CAAC,IAAIxB,KAAK,CAAG,2DAA0DnB,MAAM,CAACuC,GAAI,EAAE,CAAC,CAAC;IACtG;IACA,IAAI,CAACb,OAAO,CAAClB,qBAAqB,IAChC,CAACR,MAAM,CAACuC,GAAG,CAACQ,UAAU,CAAC,IAAI,CAAC,IAC5Bd,kBAAkB,CAACiB,oBAAoB,KAAKT,SAAS;IAAI;IACzDR,kBAAkB,CAACiB,oBAAoB,CAACC,aAAa,GAAG,IAAI,EAAE;MAC9D,OAAOR,OAAO,CAAC,IAAIxB,KAAK,CAAE,8DAA6DnB,MAAM,CAACuC,GAAI,EAAC,CAAC,CAAC;IACvG;EACF;EAEA,IAAI,OAAOX,OAAO,KAAK,WAAW,EAAE;IAClC,OAAOe,OAAO,CAAC,IAAIxB,KAAK,CAAC,qBAAqB,CAAC,CAAC;EAClD,CAAC,MAAM,IAAIgB,eAAe,EAAE;IAC1B,IAAI;MACFR,eAAe,CAACC,OAAO,CAAC;IAC1B,CAAC,CACD,OAAOwB,KAAK,EAAE;MACZ,OAAOT,OAAO,CAACS,KAAK,CAAC;IACvB;IACA,IAAI,CAAC1B,OAAO,CAACnB,aAAa,EAAE;MAC1BqB,OAAO,GAAGR,MAAM,CAACkB,MAAM,CAAC,CAAC,CAAC,EAACV,OAAO,CAAC;IACrC;EACF,CAAC,MAAM;IACL,MAAMyB,eAAe,GAAGvB,mBAAmB,CAACwB,MAAM,CAAC,UAAUC,GAAG,EAAE;MAChE,OAAO,OAAO7B,OAAO,CAAC6B,GAAG,CAAC,KAAK,WAAW;IAC5C,CAAC,CAAC;IAEF,IAAIF,eAAe,CAACG,MAAM,GAAG,CAAC,EAAE;MAC9B,OAAOb,OAAO,CAAC,IAAIxB,KAAK,CAAC,UAAU,GAAGkC,eAAe,CAACI,IAAI,CAAC,GAAG,CAAC,GAAG,cAAc,GAAI,OAAO7B,OAAS,GAAG,UAAU,CAAC,CAAC;IACrH;EACF;EAEA,IAAI,OAAOA,OAAO,CAAChB,GAAG,KAAK,WAAW,IAAI,OAAOc,OAAO,CAACpC,SAAS,KAAK,WAAW,EAAE;IAClF,OAAOqD,OAAO,CAAC,IAAIxB,KAAK,CAAC,2EAA2E,CAAC,CAAC;EACxG;EAEA,IAAI,OAAOS,OAAO,CAACf,GAAG,KAAK,WAAW,IAAI,OAAOa,OAAO,CAAChC,SAAS,KAAK,WAAW,EAAE;IAClF,OAAOiD,OAAO,CAAC,IAAIxB,KAAK,CAAC,2EAA2E,CAAC,CAAC;EACxG;EAEA,IAAI;IACFM,eAAe,CAACC,OAAO,CAAC;EAC1B,CAAC,CACD,OAAO0B,KAAK,EAAE;IACZ,OAAOT,OAAO,CAACS,KAAK,CAAC;EACvB;EAEA,IAAI,CAAC1B,OAAO,CAACjB,8BAA8B,EAAE;IAC3C,IAAI;MACFlC,qBAAqB,CAACyB,MAAM,CAACuC,GAAG,EAAEN,kBAAkB,CAAC;IACvD,CAAC,CAAC,OAAOmB,KAAK,EAAE;MACd,OAAOT,OAAO,CAACS,KAAK,CAAC;IACvB;EACF;EAEA,MAAMM,SAAS,GAAG9B,OAAO,CAACjB,GAAG,IAAIgD,IAAI,CAACC,KAAK,CAACC,IAAI,CAACC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC;EAE9D,IAAIpC,OAAO,CAACrB,WAAW,EAAE;IACvB,OAAOuB,OAAO,CAACjB,GAAG;EACpB,CAAC,MAAM,IAAIwB,eAAe,EAAE;IAC1BP,OAAO,CAACjB,GAAG,GAAG+C,SAAS;EACzB;EAEA,IAAI,OAAOhC,OAAO,CAAChC,SAAS,KAAK,WAAW,EAAE;IAC5C,IAAI;MACFkC,OAAO,CAACf,GAAG,GAAGzC,QAAQ,CAACsD,OAAO,CAAChC,SAAS,EAAEgE,SAAS,CAAC;IACtD,CAAC,CACD,OAAOd,GAAG,EAAE;MACV,OAAOD,OAAO,CAACC,GAAG,CAAC;IACrB;IACA,IAAI,OAAOhB,OAAO,CAACf,GAAG,KAAK,WAAW,EAAE;MACtC,OAAO8B,OAAO,CAAC,IAAIxB,KAAK,CAAC,iGAAiG,CAAC,CAAC;IAC9H;EACF;EAEA,IAAI,OAAOO,OAAO,CAACpC,SAAS,KAAK,WAAW,IAAI,OAAOsC,OAAO,KAAK,QAAQ,EAAE;IAC3E,IAAI;MACFA,OAAO,CAAChB,GAAG,GAAGxC,QAAQ,CAACsD,OAAO,CAACpC,SAAS,EAAEoE,SAAS,CAAC;IACtD,CAAC,CACD,OAAOd,GAAG,EAAE;MACV,OAAOD,OAAO,CAACC,GAAG,CAAC;IACrB;IACA,IAAI,OAAOhB,OAAO,CAAChB,GAAG,KAAK,WAAW,EAAE;MACtC,OAAO+B,OAAO,CAAC,IAAIxB,KAAK,CAAC,iGAAiG,CAAC,CAAC;IAC9H;EACF;EAEAC,MAAM,CAACC,IAAI,CAACQ,kBAAkB,CAAC,CAACP,OAAO,CAAC,UAAUC,GAAG,EAAE;IACrD,MAAMwC,KAAK,GAAGlC,kBAAkB,CAACN,GAAG,CAAC;IACrC,IAAI,OAAOG,OAAO,CAACH,GAAG,CAAC,KAAK,WAAW,EAAE;MACvC,IAAI,OAAOK,OAAO,CAACmC,KAAK,CAAC,KAAK,WAAW,EAAE;QACzC,OAAOpB,OAAO,CAAC,IAAIxB,KAAK,CAAC,eAAe,GAAGI,GAAG,GAAG,wCAAwC,GAAGwC,KAAK,GAAG,aAAa,CAAC,CAAC;MACrH;MACAnC,OAAO,CAACmC,KAAK,CAAC,GAAGrC,OAAO,CAACH,GAAG,CAAC;IAC/B;EACF,CAAC,CAAC;EAEF,MAAMtB,QAAQ,GAAGyB,OAAO,CAACzB,QAAQ,IAAI,MAAM;EAE3C,IAAI,OAAOiC,QAAQ,KAAK,UAAU,EAAE;IAClCA,QAAQ,GAAGA,QAAQ,IAAInD,IAAI,CAACmD,QAAQ,CAAC;IAErC1D,GAAG,CAACwF,UAAU,CAAC;MACbhE,MAAM,EAAEA,MAAM;MACdiE,UAAU,EAAEhC,kBAAkB;MAC9BL,OAAO,EAAEA,OAAO;MAChB3B,QAAQ,EAAEA;IACZ,CAAC,CAAC,CAAClB,IAAI,CAAC,OAAO,EAAEmD,QAAQ,CAAC,CACvBnD,IAAI,CAAC,MAAM,EAAE,UAAUmF,SAAS,EAAE;MACjC;MACA,IAAG,CAACxC,OAAO,CAAClB,qBAAqB,IAAI,YAAY,CAACyC,IAAI,CAACjD,MAAM,CAACuC,GAAG,CAAC,IAAI2B,SAAS,CAACV,MAAM,GAAG,GAAG,EAAE;QAC5F,OAAOtB,QAAQ,CAAC,IAAIf,KAAK,CAAE,8DAA6DnB,MAAM,CAACuC,GAAI,EAAC,CAAC,CAAC;MACxG;MACAL,QAAQ,CAAC,IAAI,EAAEgC,SAAS,CAAC;IAC3B,CAAC,CAAC;EACN,CAAC,MAAM;IACL,IAAIA,SAAS,GAAG1F,GAAG,CAAC2F,IAAI,CAAC;MAACnE,MAAM,EAAEA,MAAM;MAAE4B,OAAO,EAAEA,OAAO;MAAEwC,MAAM,EAAEnC,kBAAkB;MAAEhC,QAAQ,EAAEA;IAAQ,CAAC,CAAC;IAC5G;IACA,IAAG,CAACyB,OAAO,CAAClB,qBAAqB,IAAI,YAAY,CAACyC,IAAI,CAACjD,MAAM,CAACuC,GAAG,CAAC,IAAI2B,SAAS,CAACV,MAAM,GAAG,GAAG,EAAE;MAC5F,MAAM,IAAIrC,KAAK,CAAE,8DAA6DnB,MAAM,CAACuC,GAAI,EAAC,CAAC;IAC7F;IACA,OAAO2B,SAAS;EAClB;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}